<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamline - Futuristic</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* Dark futuristic gradient background */
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            color: #e2e8f0; /* Light text color for dark background */
            min-height: 100vh;
            overscroll-behavior: none;
        }
        .container {
            max-width: 1200px; /* Slightly wider container */
        }
        header h1 {
            /* Futuristic gradient for the title */
            background: linear-gradient(90deg, #4fd1c5 0%, #81e6d9 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(79, 209, 197, 0.3);
        }
        header p {
            color: #a0aec0; /* Lighter gray for subtitle */
        }
        .add-task-section {
            /* Slightly transparent dark background for the add task section */
            background: rgba(45, 55, 72, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 209, 197, 0.2); /* Teal border */
            border-radius: 1rem; /* Consistent rounded corners */
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
        }
        .add-task-section h2 {
            color: #e2e8f0;
            border-bottom: 1px solid rgba(79, 209, 197, 0.3);
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .kanban-column {
            min-height: 400px; /* Taller columns */
            /* Darker, slightly transparent column background */
            background: rgba(26, 32, 44, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(79, 209, 197, 0.15); /* Subtle teal border */
            border-radius: 1rem;
            padding: 1.5rem;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column; /* Ensure header is at the top */
        }
        .kanban-column.drag-over {
            /* Highlight effect when dragging over */
            background: rgba(45, 55, 72, 0.95);
            transform: scale(1.01);
            box-shadow: 0 0 25px rgba(79, 209, 197, 0.3);
            border-color: rgba(79, 209, 197, 0.4);
        }
        .column-header {
            position: relative;
            padding-bottom: 1rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid rgba(79, 209, 197, 0.3); /* Teal underline */
            color: #e2e8f0; /* Light header text */
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        /* Remove the ::after pseudo-element line */
        .column-header::after {
           display: none;
        }
        .task-list {
            flex-grow: 1; /* Allow task list to fill column height */
            max-height: calc(100vh - 350px); /* Adjust max height */
            overflow-y: auto;
            /* Custom scrollbar for webkit browsers */
            scrollbar-width: thin;
            scrollbar-color: rgba(79, 209, 197, 0.6) rgba(45, 55, 72, 0.5); /* Teal thumb, dark track */
        }
        .task-list::-webkit-scrollbar {
            width: 8px;
        }
        .task-list::-webkit-scrollbar-track {
            background: rgba(45, 55, 72, 0.5); /* Dark track */
            border-radius: 4px;
        }
        .task-list::-webkit-scrollbar-thumb {
            background: rgba(79, 209, 197, 0.6); /* Teal thumb */
            border-radius: 4px;
            border: 2px solid rgba(45, 55, 72, 0.5); /* Add border to thumb */
        }
        .task {
            /* Task card styling */
            background: rgba(45, 55, 72, 0.9); /* Darker task background */
            padding: 1rem 1.25rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            cursor: grab;
            border: 1px solid rgba(79, 209, 197, 0.2);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.12);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        /* Remove the top border pseudo-element */
        .task::before {
            display: none;
        }
        .task:hover {
            transform: translateY(-3px) scale(1.02); /* More pronounced hover */
            box-shadow: 0 10px 15px -3px rgba(79, 209, 197, 0.2), 0 4px 6px -2px rgba(79, 209, 197, 0.1);
            border-color: rgba(79, 209, 197, 0.5);
        }
        .task:active {
            cursor: grabbing;
            transform: scale(1.04); /* Slightly larger scale when grabbing */
        }
        .task.dragging {
            opacity: 0.6;
            box-shadow: 0 25px 50px -12px rgba(79, 209, 197, 0.3); /* Glow effect when dragging */
            transform: rotate(2deg); /* Slight rotation when dragging */
        }
        .task-content {
            word-break: break-word;
            color: #e2e8f0; /* Light text color for tasks */
            margin-right: 25px; /* Space for delete button */
        }
        .delete-btn {
            /* Style delete button */
            position: absolute;
            top: 0.75rem; /* Adjust position */
            right: 0.75rem;
            font-size: 1rem; /* Make icon slightly larger */
            color: #e53e3e; /* Red color for delete */
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 50%;
            line-height: 1;
            opacity: 0.6;
            transition: all 0.2s;
            background: rgba(229, 62, 62, 0.1);
            display: flex; /* Use flex for centering icon */
            align-items: center;
            justify-content: center;
            width: 24px; /* Fixed size */
            height: 24px;
        }
        .delete-btn:hover {
            opacity: 1;
            background: rgba(229, 62, 62, 0.2);
            transform: scale(1.15); /* Slightly larger hover scale */
            color: #fc8181; /* Lighter red on hover */
        }
        .task-input, .deadline-picker, .deadline-text {
            /* Input field styling */
            background: rgba(26, 32, 44, 0.9); /* Dark input background */
            border-radius: 0.75rem;
            padding: 0.9rem 1.25rem; /* Adjust padding */
            border: 1px solid rgba(79, 209, 197, 0.3);
            color: #e2e8f0; /* Light text color */
            transition: all 0.3s ease;
            width: 100%; /* Make inputs full width */
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
        }
        .task-input::placeholder, .deadline-picker::placeholder, .deadline-text::placeholder {
            color: #718096; /* Gray placeholder text */
        }
        .task-input:focus, .deadline-picker:focus, .deadline-text:focus {
            outline: none;
            border-color: #4fd1c5; /* Teal focus border */
            box-shadow: 0 0 0 3px rgba(79, 209, 197, 0.3); /* Teal focus ring */
            background: rgba(45, 55, 72, 0.95); /* Slightly lighter focus background */
        }
        .add-task-btn {
            /* Button styling */
            border-radius: 0.75rem;
            padding: 0.9rem 2rem;
            background: linear-gradient(135deg, #4fd1c5 0%, #38b2ac 100%); /* Teal gradient */
            color: #1a202c; /* Dark text on light button */
            font-weight: 600;
            transition: all 0.3s ease;
            border: none;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .add-task-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(79, 209, 197, 0.4); /* Teal glow on hover */
            background: linear-gradient(135deg, #81e6d9 0%, #4fd1c5 100%); /* Lighter teal gradient on hover */
        }
         .add-task-btn:active {
            transform: translateY(0px);
             box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .deadline-input-wrapper {
            /* Wrapper for deadline inputs */
            display: flex;
            align-items: center;
            gap: 0.5rem; /* Space between elements */
            flex-grow: 1; /* Allow wrapper to take available space */
        }
        .deadline-picker {
            flex-grow: 1; /* Allow picker to grow */
            margin-top: 0; /* Remove margin */
        }
        /* Hide text input by default */
        .deadline-text {
           display: none;
           flex-grow: 1;
           margin-top: 0;
        }
        .deadline-text.active {
            display: block; /* Show when active */
        }
        /* Hide picker when text is active */
        .deadline-picker.hidden {
            display: none;
        }
        .deadline-toggle {
            /* Toggle button styling */
            background: rgba(79, 209, 197, 0.15);
            border: 1px solid rgba(79, 209, 197, 0.3);
            color: #81e6d9; /* Light teal color */
            padding: 0.6rem; /* Adjust padding */
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2rem;
            width: 44px; /* Fixed width */
            height: 44px; /* Fixed height to match input */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Prevent shrinking */
            margin-top: 0; /* Remove margin */
        }
        .deadline-toggle:hover {
            background: rgba(79, 209, 197, 0.3);
            color: #fff;
        }
        .deadline-info {
            /* Deadline info styling */
            font-size: 0.8rem; /* Slightly smaller font */
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(79, 209, 197, 0.2);
            display: flex;
            align-items: center;
            gap: 0.4rem;
            color: #a0aec0; /* Lighter gray color */
            opacity: 0.9;
        }
        .deadline-info svg { /* Style the icon */
            width: 14px;
            height: 14px;
            stroke-width: 2;
        }
        .deadline-info.urgent {
            color: #fc8181; /* Light red for urgent */
        }
        .deadline-info.near {
            color: #f6ad55; /* Light orange for near */
        }
        #confetti-canvas {
            /* Confetti canvas styling */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through */
            z-index: 1000; /* Ensure it's above other elements */
        }
        /* Styling for the drag placeholder */
        .task-placeholder {
             height: 60px; /* Example height, adjust as needed or set dynamically */
             background-color: rgba(79, 209, 197, 0.1);
             border: 2px dashed rgba(79, 209, 197, 0.4);
             border-radius: 0.75rem;
             margin-bottom: 1rem;
             transition: none; /* No transition for placeholder itself */
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="container mx-auto">
        <header class="mb-10 text-center">
             <h1 class="text-5xl font-bold mb-3">Streamline</h1>
             <p class="text-lg">Organize your task</p>
        </header>

        <div class="add-task-section">
            <h2 class="text-2xl font-semibold">Add New Task</h2>
            <div class="flex flex-col gap-4">
                <input type="text" id="new-task-input" class="task-input flex-grow" placeholder="Enter task description...">
                <div class="flex flex-col sm:flex-row items-center gap-4">
                    <div class="deadline-input-wrapper w-full sm:w-auto">
                        <input type="datetime-local" id="task-deadline" class="deadline-picker" title="Select deadline date and time">
                        <input type="text" id="task-deadline-text" class="deadline-text" placeholder="e.g., tomorrow 3pm, next friday" title="Enter deadline description">
                        <button id="deadline-toggle" class="deadline-toggle" title="Toggle date picker/text input">
                            <i data-lucide="calendar-plus"></i>
                        </button>
                    </div>
                    <button id="add-task-btn" class="add-task-btn w-full sm:w-auto">
                         <i data-lucide="plus-circle"></i> Add Task
                    </button>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 md:gap-8">
            <div id="todo" class="kanban-column" data-column-id="todo">
                <h2 class="column-header text-teal-300">
                    <i data-lucide="list-todo" class="inline-block w-5 h-5 mr-2 align-middle"></i>To Do
                </h2>
                <div class="task-list space-y-4 pr-2">
                    </div>
            </div>

            <div id="inprogress" class="kanban-column" data-column-id="inprogress">
                 <h2 class="column-header text-cyan-300">
                     <i data-lucide="loader-circle" class="inline-block w-5 h-5 mr-2 align-middle"></i>In Progress
                 </h2>
                <div class="task-list space-y-4 pr-2">
                     </div>
            </div>

            <div id="done" class="kanban-column" data-column-id="done">
                 <h2 class="column-header text-green-300">
                     <i data-lucide="check-circle" class="inline-block w-5 h-5 mr-2 align-middle"></i>Done
                 </h2>
                <div class="task-list space-y-4 pr-2">
                     </div>
            </div>
        </div>
    </div>

    <canvas id="confetti-canvas"></canvas>

    <script>
        // DOM Elements
        const newTaskInput = document.getElementById('new-task-input');
        const addTaskBtn = document.getElementById('add-task-btn');
        const columns = document.querySelectorAll('.kanban-column');
        const confettiCanvas = document.getElementById('confetti-canvas');
        const ctx = confettiCanvas.getContext('2d');
        const deadlineToggle = document.getElementById('deadline-toggle');
        const deadlinePicker = document.getElementById('task-deadline');
        const deadlineText = document.getElementById('task-deadline-text');

        let tasks = []; // Array to store task objects { id, text, column, deadline }
        let draggedTask = null; // To keep track of the task element being dragged
        let confettiAnimationId; // To control confetti animation frame

        // --- Task Management ---

        /**
         * Creates a DOM element for a task.
         * @param {object} task - The task object { id, text, column, deadline }
         * @returns {HTMLElement} The task DOM element.
         */
        function createTaskElement(task) {
            const taskEl = document.createElement('div');
            taskEl.classList.add('task');
            taskEl.setAttribute('draggable', 'true');
            taskEl.setAttribute('data-task-id', task.id);

            // Task content wrapper
            const contentWrapper = document.createElement('div');
            
            // Task text
            const taskContent = document.createElement('span');
            taskContent.classList.add('task-content');
            taskContent.textContent = task.text;
            
            // Delete button
            const deleteBtn = document.createElement('span');
            deleteBtn.classList.add('delete-btn');
            deleteBtn.innerHTML = '&#x2716;';
            deleteBtn.title = 'Delete task';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteTask(task.id);
            });

            contentWrapper.appendChild(taskContent);
            contentWrapper.appendChild(deleteBtn);
            taskEl.appendChild(contentWrapper);

            // Add deadline info if exists
            if (task.deadline) {
                const deadlineInfo = document.createElement('div');
                deadlineInfo.classList.add('deadline-info');

                // Function to update deadline status and display
                function updateDeadlineStatus() {
                    try {
                        const now = new Date();
                        const deadline = new Date(task.deadline); // Ensure deadline is a valid Date object
                        if (isNaN(deadline.getTime())) {
                            // Handle invalid date stored in task.deadline
                            deadlineInfo.innerHTML = '<span><i data-lucide="alert-circle" class="w-3.5 h-3.5"></i> Invalid Deadline</span>';
                            deadlineInfo.classList.add('urgent');
                             lucide.createIcons();
                            return;
                        }

                        const timeLeft = deadline - now;

                        // Clear existing classes and content
                        deadlineInfo.classList.remove('urgent', 'near');
                        deadlineInfo.innerHTML = ''; // Clear previous content

                        // Create icon span
                        const iconSpan = document.createElement('span');
                        iconSpan.innerHTML = '<i data-lucide="clock" class="w-3.5 h-3.5"></i>'; // Clock icon

                        // Create text span
                        const textSpan = document.createElement('span');

                        if (timeLeft < 0) {
                            textSpan.textContent = `Overdue by ${formatTimeLeft(-timeLeft)}`;
                            deadlineInfo.classList.add('urgent');
                            iconSpan.innerHTML = '<i data-lucide="alert-triangle" class="w-3.5 h-3.5"></i>'; // Warning icon
                        } else {
                            const formattedTime = formatTimeLeft(timeLeft);
                            textSpan.textContent = `${formattedTime} remaining`;
                            if (timeLeft < 24 * 60 * 60 * 1000) { // Less than 24 hours
                                deadlineInfo.classList.add('urgent');
                            } else if (timeLeft < 72 * 60 * 60 * 1000) { // Less than 3 days
                                deadlineInfo.classList.add('near');
                            }
                        }
                        deadlineInfo.appendChild(iconSpan);
                        deadlineInfo.appendChild(textSpan);
                        lucide.createIcons(); // Re-render Lucide icons if added dynamically
                    } catch (error) {
                         console.error("Error updating deadline status:", error);
                         deadlineInfo.innerHTML = '<span><i data-lucide="alert-circle" class="w-3.5 h-3.5"></i> Error</span>';
                         deadlineInfo.classList.add('urgent');
                         lucide.createIcons();
                    }
                }


                updateDeadlineStatus();
                // Update the countdown every minute
                const intervalId = setInterval(updateDeadlineStatus, 60000);
                // Store the interval ID on the element to clear it when the task is removed
                taskEl.dataset.intervalId = intervalId;

                taskEl.appendChild(deadlineInfo);
            }

            // Drag event listeners for the task element
            taskEl.addEventListener('dragstart', handleDragStart);
            taskEl.addEventListener('dragend', handleDragEnd);

            // Touch event listeners for mobile drag-and-drop
            taskEl.addEventListener('touchstart', handleTouchStart, { passive: false });
            taskEl.addEventListener('touchmove', handleTouchMove, { passive: false });
            taskEl.addEventListener('touchend', handleTouchEnd);

            // Render Lucide icons within the created task element
            lucide.createIcons({
                attrs: {
                    'stroke-width': 1.75, // Thinner lines for icons in tasks
                 },
                nodes: [deleteBtn] // Only render the delete icon initially
            });


            return taskEl;
        }

        /**
         * Formats milliseconds into a human-readable time string (e.g., "2d 3h", "5h 30m", "15m").
         * @param {number} ms - Time in milliseconds
         * @returns {string} Formatted time string
         */
        function formatTimeLeft(ms) {
            const totalMinutes = Math.floor(ms / (60 * 1000));
            const totalHours = Math.floor(totalMinutes / 60);
            const days = Math.floor(totalHours / 24);

            const minutes = totalMinutes % 60;
            const hours = totalHours % 24;

            let result = '';
            if (days > 0) {
                result += `${days}d `;
            }
            if (hours > 0) {
                result += `${hours}h `;
            }
            // Only show minutes if less than a day or if it's the only unit left
            if (days === 0 && minutes > 0) {
                 result += `${minutes}m`;
            }
             // If the total time is less than a minute show '<1m'
            if (result.trim() === '' && totalMinutes < 1 && ms > 0) { // Check ms > 0 to avoid showing <1m for exactly 0
                return '<1m';
            }
             // If only days/hours are shown, remove trailing space
            return result.trim();
        }


        /**
         * Adds a new task to the "To Do" column.
         */
        function addNewTask() {
            const taskText = newTaskInput.value.trim();
            let deadline = null;

            // Get deadline from either the picker or text input
            if (!deadlinePicker.classList.contains('hidden')) {
                deadline = deadlinePicker.value;
            } else if (deadlineText.value && deadlineText.value.trim() !== '') {
                const parsedDate = parseUserDate(deadlineText.value);
                if (parsedDate) {
                    deadline = parsedDate.toISOString();
                }
            }

            if (taskText === '') {
                newTaskInput.classList.add('border-red-500');
                newTaskInput.placeholder = "Task description cannot be empty!";
                setTimeout(() => {
                    newTaskInput.classList.remove('border-red-500');
                    newTaskInput.placeholder = "Enter task description...";
                }, 2000);
                return;
            }

            const newTask = {
                id: `task-${Date.now()}`,
                text: taskText,
                column: 'todo',
                deadline: deadline
            };

            tasks.push(newTask);
            renderTasks();
            saveTasksToLocalStorage();
            
            // Clear inputs
            newTaskInput.value = '';
            deadlinePicker.value = '';
            deadlineText.value = '';
            newTaskInput.focus();
        }

        /**
         * Deletes a task by its ID from the tasks array and updates the UI and local storage.
         * @param {string} taskId - The ID of the task to delete.
         */
        function deleteTask(taskId) {
            const taskEl = document.querySelector(`[data-task-id="${taskId}"]`);
            // Clear the deadline update interval if it exists
            if (taskEl && taskEl.dataset.intervalId) {
                clearInterval(Number(taskEl.dataset.intervalId));
            }
            // Filter out the task to be deleted
            tasks = tasks.filter(task => task.id !== taskId);
            renderTasks(); // Re-render the task list
            saveTasksToLocalStorage(); // Update local storage
        }

        // --- Drag and Drop Functionality ---

        function handleDragStart(event) {
            draggedTask = this; // `this` refers to the task element being dragged
            // Use setTimeout to allow the browser to render the drag image before applying styles
            setTimeout(() => this.classList.add('dragging'), 0);
            event.dataTransfer.effectAllowed = 'move';
            // Set data payload (using task ID)
            event.dataTransfer.setData('text/plain', this.dataset.taskId);
        }

        function handleDragEnd() {
            // Remove dragging class regardless of drop success
            if (draggedTask) { // Check if draggedTask is still set
                 draggedTask.classList.remove('dragging');
            }
             // Remove any leftover placeholders
             document.querySelectorAll('.task-placeholder').forEach(p => p.remove());
            draggedTask = null;
            // Clean up drag-over styling from all columns
            columns.forEach(col => col.classList.remove('drag-over'));
        }

        function handleDragOver(event) {
            event.preventDefault(); // Necessary to allow dropping
            event.dataTransfer.dropEffect = 'move';
            // Add visual feedback to the column being dragged over
            // Avoid adding class if already present to prevent flicker
            if (!this.classList.contains('drag-over')) {
                 this.classList.add('drag-over');
            }

             // --- Placeholder logic for drag over ---
             if (draggedTask) {
                const taskList = this.querySelector('.task-list');
                const afterElement = getDragAfterElement(taskList, event.clientY);

                // Ensure placeholder exists and is managed correctly
                let placeholder = document.querySelector('.task-placeholder');
                if (!placeholder) {
                     placeholder = document.createElement('div');
                     placeholder.classList.add('task-placeholder');
                     placeholder.style.height = `${draggedTask.offsetHeight}px`; // Match height
                     // Styles are now in CSS, just add the class
                }


                // Insert the placeholder at the correct position within this column
                if (afterElement == null) {
                    // Append to the end if no element is below the cursor
                     taskList.appendChild(placeholder);
                } else {
                     // Insert before the element below the cursor
                     taskList.insertBefore(placeholder, afterElement);
                }
            }
        }

        // Helper function to determine where to insert the dragged item
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.task:not(.dragging):not(.task-placeholder)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                // Find the element whose midpoint is just below the cursor
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }


        function handleDragEnter(event) {
            event.preventDefault();
            // Add visual feedback - already handled by dragOver, but good for redundancy
             if (!this.classList.contains('drag-over')) {
                 this.classList.add('drag-over');
            }
        }

        function handleDragLeave(event) {
             // Only remove drag-over if leaving the column itself, not just moving over children
             if (event.target === this || !this.contains(event.relatedTarget)) {
                this.classList.remove('drag-over');
                // Remove placeholder if leaving the column entirely
                const placeholder = document.querySelector('.task-placeholder'); // Find globally
                if (placeholder && placeholder.closest('.kanban-column') === this && !this.contains(event.relatedTarget)) { // Check relatedTarget again
                    placeholder.remove();
                }
             }
        }

        function handleDrop(event) {
            event.preventDefault();
            this.classList.remove('drag-over'); // Remove drop zone styling
            const placeholder = document.querySelector('.task-placeholder'); // Find globally
             if (placeholder) {
                 placeholder.remove(); // Remove placeholder on drop
             }


            const taskId = event.dataTransfer.getData('text/plain');
            const targetColumnId = this.dataset.columnId; // Get the ID of the column where dropped

            const taskToMove = tasks.find(task => task.id === taskId);

            if (taskToMove && draggedTask) { // Ensure task exists and was being dragged
                const previousColumn = taskToMove.column;
                taskToMove.column = targetColumnId; // Update the task's column property

                // --- Handle task reordering within the column ---
                const droppedOnTaskList = this.querySelector('.task-list');
                const afterElement = getDragAfterElement(droppedOnTaskList, event.clientY);
                const taskIndex = tasks.findIndex(t => t.id === taskId);
                const [movedTask] = tasks.splice(taskIndex, 1); // Remove task from original position

                // Find the correct index to insert into the main `tasks` array based on visual drop position
                let insertAtIndex = -1;
                if (afterElement == null) {
                    // Dropped at the end of the list or in an empty list
                    // Find the index of the last task currently in the target column
                    const lastTaskInColumnIndex = tasks.findLastIndex(t => t.column === targetColumnId);
                     insertAtIndex = lastTaskInColumnIndex + 1; // Insert after the last task
                } else {
                    // Dropped before 'afterElement'
                    insertAtIndex = tasks.findIndex(t => t.id === afterElement.dataset.taskId);
                }

                 // If insertAtIndex is -1 (e.g., dropping into an empty column that wasn't handled above),
                 // simply push it to the end (or handle as needed).
                 if (insertAtIndex === -1) {
                     // This case should ideally be handled by the afterElement == null logic,
                     // but as a fallback, push to the end.
                     tasks.push(movedTask);
                 } else {
                    tasks.splice(insertAtIndex, 0, movedTask); // Insert at the calculated index
                 }
                // --- End reordering logic ---


                // Trigger confetti if moved to "Done" from another column
                if (targetColumnId === 'done' && previousColumn !== 'done') {
                    // Get drop position for confetti origin
                    const dropRect = draggedTask.getBoundingClientRect();
                    triggerConfetti(dropRect.left + dropRect.width / 2, dropRect.top + dropRect.height / 2);
                }

                // Re-render tasks to reflect the change (including order)
                renderTasks();
                saveTasksToLocalStorage(); // Persist the change
            }
             draggedTask = null; // Reset draggedTask after drop
        }

        // --- Touch Drag and Drop Emulation ---
        let touchDragElement = null; // The element visually moved during touch drag
        let touchStartX, touchStartY; // Initial touch coordinates
        let currentDroppable = null; // The column currently being touched over
        let placeholderElement = null; // Placeholder for touch drag visual feedback
        let originalTaskElement = null; // Reference to the actual task element being dragged

         function handleTouchStart(event) {
            // Only allow dragging with one finger
            if (event.touches.length > 1) return;

            // Prevent drag start on delete button
             if (event.target.closest('.delete-btn')) {
                 return;
             }

            originalTaskElement = this; // The actual task element touched
            originalTaskElement.style.opacity = '0.5'; // Make original slightly transparent

            // Clone the element for visual dragging feedback
            touchDragElement = this.cloneNode(true);
            touchDragElement.style.position = 'fixed'; // Position fixed for dragging
            touchDragElement.style.zIndex = '1000';
            touchDragElement.style.pointerEvents = 'none'; // Don't interfere with elementFromPoint
            touchDragElement.style.width = `${this.offsetWidth}px`; // Maintain width
            touchDragElement.style.height = `${this.offsetHeight}px`; // Maintain height
            touchDragElement.style.transition = 'none'; // No transitions while dragging clone
            touchDragElement.classList.add('dragging'); // Apply dragging style to clone
             // Remove delete button from clone for cleaner look
             const cloneDeleteBtn = touchDragElement.querySelector('.delete-btn');
             if (cloneDeleteBtn) cloneDeleteBtn.remove();
            document.body.appendChild(touchDragElement); // Add clone to body

            // Create placeholder
            placeholderElement = document.createElement('div');
            placeholderElement.classList.add('task-placeholder'); // Use the same placeholder class
            placeholderElement.style.height = `${this.offsetHeight}px`;
            // Styles are in CSS

            // Calculate offset within the element
            const rect = this.getBoundingClientRect();
            touchStartX = event.touches[0].clientX - rect.left;
            touchStartY = event.touches[0].clientY - rect.top;

            // Position the clone initially
            touchDragElement.style.left = (event.touches[0].clientX - touchStartX) + 'px';
            touchDragElement.style.top = (event.touches[0].clientY - touchStartY) + 'px';

             // Insert placeholder where the original element was
             this.parentNode.insertBefore(placeholderElement, this);

            event.preventDefault(); // Prevent scrolling
        }

        function handleTouchMove(event) {
            if (!touchDragElement || event.touches.length > 1) return;
            event.preventDefault(); // Prevent scrolling

            const touchX = event.touches[0].clientX;
            const touchY = event.touches[0].clientY;

            // Move the cloned element
            touchDragElement.style.left = (touchX - touchStartX) + 'px';
            touchDragElement.style.top = (touchY - touchStartY) + 'px';

            // --- Droppable detection ---
            // Temporarily hide the clone to find element underneath
            touchDragElement.style.display = 'none';
            const elementBelow = document.elementFromPoint(touchX, touchY);
            touchDragElement.style.display = ''; // Show clone again

            let targetColumnElement = elementBelow;
            // Traverse up to find the kanban column
            while (targetColumnElement && !targetColumnElement.classList.contains('kanban-column')) {
                targetColumnElement = targetColumnElement.parentElement;
            }

            // If over a new column or no column
            if (targetColumnElement !== currentDroppable) {
                // Remove highlight and placeholder from previous column
                if (currentDroppable) {
                    currentDroppable.classList.remove('drag-over');
                     if (placeholderElement.parentNode === currentDroppable.querySelector('.task-list')) {
                         placeholderElement.remove();
                     }
                }
                currentDroppable = targetColumnElement; // Update current droppable
                // Add highlight to the new column
                if (currentDroppable) {
                    currentDroppable.classList.add('drag-over');
                }
            }

            // --- Placeholder positioning within the current column ---
            if (currentDroppable) {
                const taskList = currentDroppable.querySelector('.task-list');
                 // Use the same helper function as desktop drag/drop
                const afterElement = getDragAfterElement(taskList, touchY);

                // Insert placeholder at the correct position
                if (afterElement == null) {
                    taskList.appendChild(placeholderElement);
                } else {
                    taskList.insertBefore(placeholderElement, afterElement);
                }
            } else {
                 // If not over any column, remove the placeholder
                 if (placeholderElement.parentNode) {
                    placeholderElement.remove();
                 }
            }
        }

        function handleTouchEnd(event) {
            if (!touchDragElement) return;

            // Restore original element visibility
             if(originalTaskElement) {
                originalTaskElement.style.opacity = '';
             }

            // Remove the cloned element
            document.body.removeChild(touchDragElement);
            touchDragElement = null;

            // If dropped on a valid column
            if (currentDroppable && originalTaskElement) {
                currentDroppable.classList.remove('drag-over');
                const targetColumnId = currentDroppable.dataset.columnId;
                const taskId = originalTaskElement.dataset.taskId;

                const taskToMove = tasks.find(task => task.id === taskId);
                if (taskToMove) {
                    const previousColumn = taskToMove.column;
                    taskToMove.column = targetColumnId; // Update task data column

                    // --- Handle reordering ---
                    const touchY = event.changedTouches[0].clientY; // Get final touch position
                    const droppedOnTaskList = currentDroppable.querySelector('.task-list');
                    const afterElement = getDragAfterElement(droppedOnTaskList, touchY);
                    const taskIndex = tasks.findIndex(t => t.id === taskId);
                    const [movedTask] = tasks.splice(taskIndex, 1); // Remove task

                     // Find the correct index to insert into the main `tasks` array
                     let insertAtIndex = -1;
                     if (afterElement == null) {
                         const lastTaskInColumnIndex = tasks.findLastIndex(t => t.column === targetColumnId);
                         insertAtIndex = lastTaskInColumnIndex + 1;
                     } else {
                         insertAtIndex = tasks.findIndex(t => t.id === afterElement.dataset.taskId);
                     }

                     if (insertAtIndex === -1) {
                         tasks.push(movedTask); // Fallback: add to end
                     } else {
                        tasks.splice(insertAtIndex, 0, movedTask); // Insert at correct index
                     }
                    // --- End reordering ---


                     // Trigger confetti if moved to "Done"
                     if (targetColumnId === 'done' && previousColumn !== 'done') {
                         const dropRect = originalTaskElement.getBoundingClientRect(); // Use original element's position
                         triggerConfetti(dropRect.left + dropRect.width / 2, dropRect.top + dropRect.height / 2);
                     }

                    renderTasks(); // Re-render UI
                    saveTasksToLocalStorage(); // Save changes
                }
            } else {
                // If not dropped on a valid column, re-render to snap back
                 renderTasks();
            }

             // Remove placeholder regardless of drop location
             if (placeholderElement && placeholderElement.parentNode) {
                placeholderElement.remove();
             }

            // Reset states
            placeholderElement = null;
            currentDroppable = null;
            originalTaskElement = null;
        }


        // --- Rendering and Local Storage ---

        /**
         * Renders all tasks from the `tasks` array into their respective columns in the DOM.
         * Ensures tasks are rendered in the order they appear in the `tasks` array.
         */
        function renderTasks() {
            // Store current scroll positions
            const scrollPositions = {};
            columns.forEach(column => {
                const taskList = column.querySelector('.task-list');
                scrollPositions[column.id] = taskList.scrollTop;
                 // Clear interval timers for tasks about to be removed
                 taskList.querySelectorAll('.task[data-interval-id]').forEach(taskEl => {
                     if (taskEl.dataset.intervalId) {
                        clearInterval(Number(taskEl.dataset.intervalId));
                        delete taskEl.dataset.intervalId; // Clean up dataset attribute
                     }
                 });
                taskList.innerHTML = ''; // Clear the list content
            });


            // Add tasks to their correct columns based on the current order in the tasks array
            tasks.forEach(task => {
                const taskEl = createTaskElement(task); // Create the DOM element
                const columnEl = document.getElementById(task.column);
                if (columnEl) {
                    columnEl.querySelector('.task-list').appendChild(taskEl); // Append to the column's task list
                } else {
                    console.warn(`Column with ID ${task.column} not found for task ${task.id}. Defaulting to 'todo'.`);
                    task.column = 'todo'; // Correct the task data
                    document.getElementById('todo').querySelector('.task-list').appendChild(taskEl);
                    // Consider saving immediately if correcting data: saveTasksToLocalStorage();
                }
            });

             // Re-initialize Lucide icons for any dynamically added icons
             lucide.createIcons();

             // Restore scroll positions
             columns.forEach(column => {
                 if (scrollPositions[column.id] !== undefined) {
                    column.querySelector('.task-list').scrollTop = scrollPositions[column.id];
                 }
             });
        }

        /**
         * Saves the current `tasks` array to local storage as a JSON string.
         */
        function saveTasksToLocalStorage() {
            try {
                localStorage.setItem('kanbanTasksFuturistic', JSON.stringify(tasks));
            } catch (e) {
                console.error("Failed to save tasks to local storage:", e);
                // Optionally notify the user, e.g., via a small non-blocking message
            }
        }

        /**
         * Loads tasks from local storage and populates the `tasks` array.
         */
        function loadTasksFromLocalStorage() {
            const storedTasks = localStorage.getItem('kanbanTasksFuturistic');
            if (storedTasks) {
                try {
                    const parsedTasks = JSON.parse(storedTasks);
                     // Basic validation (ensure it's an array and tasks have basic structure)
                     if (Array.isArray(parsedTasks) && parsedTasks.every(t => t && typeof t.id === 'string' && typeof t.text === 'string' && typeof t.column === 'string')) {
                         tasks = parsedTasks;
                     } else {
                         console.warn("Invalid data structure found in local storage. Resetting tasks.");
                         tasks = [];
                         localStorage.removeItem('kanbanTasksFuturistic'); // Clear invalid data
                     }
                } catch (e) {
                    console.error("Failed to parse tasks from local storage:", e);
                    tasks = []; // Reset to empty array on parsing error
                    localStorage.removeItem('kanbanTasksFuturistic'); // Clear corrupted data
                }
            } else {
                tasks = []; // Initialize with empty array if nothing is stored
            }
        }


        // --- Confetti Animation ---
        let confettiParticles = [];
        // Futuristic color palette for confetti
        const confettiColors = ['#4fd1c5', '#81e6d9', '#38b2ac', '#4dc0b5', '#319795', '#ffffff', '#e2e8f0'];

        function ConfettiParticle(startX, startY) {
            // Start confetti from where the task was dropped or center if not specified
            this.x = startX || confettiCanvas.width / 2;
            this.y = startY || confettiCanvas.height / 2;
            this.size = Math.random() * 6 + 4; // Slightly larger confetti
            this.speedX = Math.random() * 8 - 4; // Wider horizontal spread
            this.speedY = Math.random() * -12 - 6; // Stronger initial upward burst
            this.color = confettiColors[Math.floor(Math.random() * confettiColors.length)];
            this.opacity = 1;
            this.rotation = Math.random() * 360;
            this.spin = Math.random() * 16 - 8; // Faster spin
            this.gravity = 0.25; // Slightly stronger gravity
            this.drag = 0.98; // Air resistance
        }

        ConfettiParticle.prototype.update = function() {
            this.speedX *= this.drag; // Apply air resistance
            this.x += this.speedX;
            this.speedY += this.gravity; // Apply gravity
            this.y += this.speedY;
            this.opacity -= 0.008; // Slower fade out
            this.rotation += this.spin;
        };

        ConfettiParticle.prototype.draw = function() {
            ctx.save();
            ctx.globalAlpha = this.opacity < 0 ? 0 : this.opacity; // Ensure alpha doesn't go below 0
            ctx.fillStyle = this.color;
            ctx.translate(this.x + this.size / 2, this.y + this.size / 2);
            ctx.rotate(this.rotation * Math.PI / 180);
            // Draw slightly different shapes (mix rectangles and squares)
            if (Math.random() > 0.5) {
                 ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size); // Square
            } else {
                 ctx.fillRect(-this.size / 2, -this.size / 2, this.size * 0.8, this.size * 1.5); // Rectangle
            }
            ctx.restore();
        };

        function triggerConfetti(x, y) {
            // Ensure canvas dimensions are up-to-date
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
            confettiParticles = []; // Clear previous particles
            const numberOfParticles = 180; // More particles
            for (let i = 0; i < numberOfParticles; i++) {
                confettiParticles.push(new ConfettiParticle(x, y)); // Pass starting coordinates
            }
             // Start animation if not already running
             if (!confettiAnimationId) {
                animateConfetti();
             }
        }

        function animateConfetti() {
            ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            let stillAnimating = false;
            confettiParticles = confettiParticles.filter(particle => {
                if (particle.opacity > 0 && particle.y < confettiCanvas.height + particle.size) { // Check if visible or just below screen
                    particle.update();
                    particle.draw();
                    stillAnimating = true; // Continue animation if any particle is still active
                    return true; // Keep particle
                }
                return false; // Remove particle
            });

            if (stillAnimating) {
                confettiAnimationId = requestAnimationFrame(animateConfetti);
            } else {
                 // Clear canvas completely when animation stops
                 ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
                cancelAnimationFrame(confettiAnimationId);
                confettiAnimationId = null; // Reset animation ID
            }
        }

        // --- Date Parsing (Refactored) ---

        /**
         * Helper function to parse time strings (e.g., "5pm", "14:30", "9 AM").
         * @param {string} timeInput - The time string.
         * @returns {{hours: number, minutes: number}|null} Parsed time or null.
         */
        function parseTime(timeInput) {
             timeInput = timeInput.toLowerCase().trim();
             const timeMatch = timeInput.match(/^(\d{1,2})(?::(\d{2}))?\s*(am|pm)?$/);
             if (timeMatch) {
                 let [, hours, minutes = '0', meridiem] = timeMatch;
                 hours = parseInt(hours);
                 minutes = parseInt(minutes);

                 if (isNaN(hours) || isNaN(minutes) || hours > 23 || minutes > 59 || hours < 0) return null; // Basic validation

                 if (meridiem === 'pm' && hours >= 1 && hours <= 11) {
                     hours += 12;
                 } else if (meridiem === 'am' && hours === 12) { // Handle 12 AM (midnight)
                     hours = 0;
                 }
                 // No change needed for 12 PM (noon) or 24-hour format

                 // Final check for hours after potential conversion
                 if (hours > 23) return null;

                 return { hours, minutes };
             }
             return null;
        }

        /**
        * Parses user-friendly date/time strings into Date objects.
        * Handles formats like "today", "tomorrow 5pm", "next friday", "2 days from now", "2025-05-20 14:30".
        * @param {string} input - The user's date/time string.
        * @returns {Date|null} A Date object or null if parsing fails.
        */
        function parseUserDate(input) {
            input = input.toLowerCase().trim();
            const now = new Date();
            let date = new Date(now); // Start with a copy of now
            let timeInfo = null; // To store parsed time if found separately

             // --- Attempt direct parsing first (handles ISO, YYYY-MM-DD HH:MM, etc.) ---
             if (input.match(/\d{4}/) && input.length >= 8) { // Basic check for year and length
                 const directParse = new Date(input);
                 if (!isNaN(directParse.getTime())) {
                     // Check if it parsed only the date part (time defaults to 00:00)
                     // If the original input likely contained time info (e.g., "pm", ":"),
                     // but the direct parse resulted in midnight, it might be wrong.
                     // However, direct parsing is often the most reliable, so we'll trust it here.
                     return directParse;
                 }
             }

            // --- Extract Time Part ---
            // Look for time patterns at the end of the string
            const timePattern = /(\s+\d{1,2}(?::\d{2})?\s*(?:am|pm)?)$/;
            const timeMatch = input.match(timePattern);
            let datePartStr = input; // Assume the whole string is the date part initially

            if (timeMatch) {
                const potentialTimeStr = timeMatch[1].trim();
                const parsedTime = parseTime(potentialTimeStr);
                if (parsedTime) {
                    timeInfo = parsedTime; // Store parsed time
                    datePartStr = input.substring(0, input.lastIndexOf(timeMatch[1])).trim(); // The rest is the date part
                     if (!datePartStr) datePartStr = 'today'; // Default to today if only time was given
                }
                // If parseTime failed, treat the whole string as datePartStr
            }

            // --- Parse Date Part ---
            date = new Date(now); // Reset date to now for relative calculations
            let datePartParsed = false;

            // 1. Simple Relative Terms
            if (datePartStr === 'today') {
                datePartParsed = true; // Keep today's date
            } else if (datePartStr === 'tomorrow') {
                date.setDate(now.getDate() + 1);
                datePartParsed = true;
            }
            // 2. Relative Units ("in X units", "X units from now")
            else {
                 const relativeMatch = datePartStr.match(/^(?:in\s+)?(\d+)\s+(min|minute|hour|day|week)s?(?:\s+from now|\s+later)?$/);
                 if (relativeMatch) {
                     const [, amount, unit] = relativeMatch;
                     const numAmount = parseInt(amount);
                     switch (unit) {
                         case 'min': case 'minute': date.setMinutes(now.getMinutes() + numAmount); break;
                         case 'hour': date.setHours(now.getHours() + numAmount); break;
                         case 'day': date.setDate(now.getDate() + numAmount); break;
                         case 'week': date.setDate(now.getDate() + numAmount * 7); break;
                     }
                     datePartParsed = true;
                 }
                 // 3. Days of the Week ("next friday", "monday")
                 else {
                     const daysOfWeek = { 'sunday': 0, 'monday': 1, 'tuesday': 2, 'wednesday': 3, 'thursday': 4, 'friday': 5, 'saturday': 6 };
                     for (const day in daysOfWeek) {
                         if (datePartStr.includes(day)) {
                             const targetDay = daysOfWeek[day];
                             let daysToAdd = (targetDay - now.getDay() + 7) % 7;
                             if (daysToAdd === 0 && datePartStr.startsWith('next')) {
                                 daysToAdd = 7;
                             } else if (daysToAdd === 0 && !datePartStr.startsWith('next')) {
                                 // If time is specified and already past today, assume next week
                                 if (timeInfo && (now.getHours() > timeInfo.hours || (now.getHours() === timeInfo.hours && now.getMinutes() >= timeInfo.minutes))) {
                                     daysToAdd = 7;
                                 }
                                 // Otherwise, it's today (daysToAdd remains 0)
                             } else if (daysToAdd === 0) { // Should not happen if handled above, but fallback
                                  daysToAdd = 7;
                             }
                             date.setDate(now.getDate() + daysToAdd);
                             datePartParsed = true;
                             break; // Stop after finding the first matching day
                         }
                     }
                 }
            }

             // 4. If date part wasn't parsed by relative terms, try direct parsing again
             if (!datePartParsed) {
                 const directDateParse = new Date(datePartStr);
                 if (!isNaN(directDateParse.getTime()) && datePartStr.match(/\d/)) { // Check validity and if it contains numbers
                     date = directDateParse;
                     datePartParsed = true;
                 }
             }

            // If the date part could not be determined, fail parsing
            if (!datePartParsed) {
                return null;
            }

            // --- Combine Date and Time ---
            // If time was parsed separately, apply it. Otherwise, use a default time.
            if (timeInfo) {
                date.setHours(timeInfo.hours, timeInfo.minutes, 0, 0);
            } else {
                // If no time was specified, default to a reasonable time (e.g., 9 AM for future dates, 5 PM for today)
                const isToday = date.getFullYear() === now.getFullYear() &&
                                date.getMonth() === now.getMonth() &&
                                date.getDate() === now.getDate();
                if (isToday) {
                     date.setHours(17, 0, 0, 0); // 5 PM for today
                } else {
                     date.setHours(9, 0, 0, 0); // 9 AM for future dates
                }
            }

            return date; // Return the final Date object
        }


        // --- Event Listeners Setup ---
        addTaskBtn.addEventListener('click', addNewTask);

        // Allow adding task by pressing Enter in the input fields
        newTaskInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent form submission if inside a form
                addNewTask();
            }
        });
        deadlineText.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                 e.preventDefault();
                addNewTask();
            }
        });
         deadlinePicker.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                 e.preventDefault();
                addNewTask();
            }
        });


        // Add drag event listeners to columns
        columns.forEach(column => {
            column.addEventListener('dragover', handleDragOver);
            column.addEventListener('dragenter', handleDragEnter);
            column.addEventListener('dragleave', handleDragLeave);
            column.addEventListener('drop', handleDrop);
        });

        // Add toggle functionality
        deadlineToggle.addEventListener('click', () => {
            deadlinePicker.classList.toggle('hidden');
            deadlineText.classList.toggle('hidden');
            
            // If switching to text input, copy the picker value
            if (!deadlineText.classList.contains('hidden') && deadlinePicker.value) {
                const date = new Date(deadlinePicker.value);
                deadlineText.value = date.toLocaleString();
            }
            // If switching to picker and text has a valid date, copy it
            else if (!deadlinePicker.classList.contains('hidden') && deadlineText.value) {
                const parsedDate = parseUserDate(deadlineText.value);
                if (parsedDate) {
                    deadlinePicker.value = parsedDate.toISOString().slice(0, 16);
                }
            }
        });

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadTasksFromLocalStorage(); // Load saved tasks
            renderTasks(); // Display tasks on the board

             // Initialize Lucide icons on load
             lucide.createIcons();

            // Adjust confetti canvas size on window resize
            window.addEventListener('resize', () => {
                 // Only resize if an animation is potentially active or recently finished
                 if (confettiParticles.length > 0 || confettiAnimationId) {
                    confettiCanvas.width = window.innerWidth;
                    confettiCanvas.height = window.innerHeight;
                 }
            });

            // Set initial state for deadline input (picker visible)
            deadlinePicker.classList.remove('hidden');
            deadlineText.classList.remove('active');
            deadlineText.style.display = 'none'; // Ensure text is hidden initially
            const initialToggleIcon = deadlineToggle.querySelector('i');
             // Set initial icon based on picker being visible
            initialToggleIcon.setAttribute('data-lucide', 'text-cursor-input');
            deadlineToggle.title = 'Switch to text input';
            lucide.createIcons({ nodes: [initialToggleIcon] });

        });
    </script>
</body>
</html>
