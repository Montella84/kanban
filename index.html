<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamline - Futuristic</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/lucide-static@latest/dist/lucide.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* Dark futuristic gradient background */
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            color: #e2e8f0; /* Light text color for dark background */
            min-height: 100vh;
            overscroll-behavior: none;
        }
        .container {
            max-width: 1200px; /* Slightly wider container */
        }
        header h1 {
            /* Futuristic gradient for the title */
            background: linear-gradient(90deg, #4fd1c5 0%, #81e6d9 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(79, 209, 197, 0.3);
        }
        header p {
            color: #a0aec0; /* Lighter gray for subtitle */
        }
        .add-task-section {
            /* Slightly transparent dark background for the add task section */
            background: rgba(45, 55, 72, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 209, 197, 0.2); /* Teal border */
            border-radius: 1rem; /* Consistent rounded corners */
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
        }
        .add-task-section h2 {
            color: #e2e8f0;
            border-bottom: 1px solid rgba(79, 209, 197, 0.3);
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .kanban-column {
            min-height: 400px; /* Taller columns */
            /* Darker, slightly transparent column background */
            background: rgba(26, 32, 44, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(79, 209, 197, 0.15); /* Subtle teal border */
            border-radius: 1rem;
            padding: 1.5rem;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column; /* Ensure header is at the top */
        }
        .kanban-column.drag-over {
            /* Highlight effect when dragging over */
            background: rgba(45, 55, 72, 0.95);
            transform: scale(1.01);
            box-shadow: 0 0 25px rgba(79, 209, 197, 0.3);
            border-color: rgba(79, 209, 197, 0.4);
        }
        .column-header {
            position: relative;
            padding-bottom: 1rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid rgba(79, 209, 197, 0.3); /* Teal underline */
            color: #e2e8f0; /* Light header text */
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        /* Remove the ::after pseudo-element line */
        .column-header::after {
           display: none;
        }
        .task-list {
            flex-grow: 1; /* Allow task list to fill column height */
            max-height: calc(100vh - 350px); /* Adjust max height */
            overflow-y: auto;
            /* Custom scrollbar for webkit browsers */
            scrollbar-width: thin;
            scrollbar-color: rgba(79, 209, 197, 0.6) rgba(45, 55, 72, 0.5); /* Teal thumb, dark track */
        }
        .task-list::-webkit-scrollbar {
            width: 8px;
        }
        .task-list::-webkit-scrollbar-track {
            background: rgba(45, 55, 72, 0.5); /* Dark track */
            border-radius: 4px;
        }
        .task-list::-webkit-scrollbar-thumb {
            background: rgba(79, 209, 197, 0.6); /* Teal thumb */
            border-radius: 4px;
            border: 2px solid rgba(45, 55, 72, 0.5); /* Add border to thumb */
        }
        .task {
            /* Task card styling */
            background: rgba(45, 55, 72, 0.9); /* Darker task background */
            padding: 1rem 1.25rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            cursor: grab;
            border: 1px solid rgba(79, 209, 197, 0.2);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.12);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        /* Remove the top border pseudo-element */
        .task::before {
            display: none;
        }
        .task:hover {
            transform: translateY(-3px) scale(1.02); /* More pronounced hover */
            box-shadow: 0 10px 15px -3px rgba(79, 209, 197, 0.2), 0 4px 6px -2px rgba(79, 209, 197, 0.1);
            border-color: rgba(79, 209, 197, 0.5);
        }
        .task:active {
            cursor: grabbing;
            transform: scale(1.04); /* Slightly larger scale when grabbing */
        }
        .task.dragging {
            opacity: 0.6;
            box-shadow: 0 25px 50px -12px rgba(79, 209, 197, 0.3); /* Glow effect when dragging */
            transform: rotate(2deg); /* Slight rotation when dragging */
        }
        .task-content {
            word-break: break-word;
            color: #e2e8f0; /* Light text color for tasks */
            margin-right: 25px; /* Space for delete button */
        }
        .delete-btn {
            /* Style delete button */
            position: absolute;
            top: 0.75rem; /* Adjust position */
            right: 0.75rem;
            font-size: 1rem; /* Make icon slightly larger */
            color: #e53e3e; /* Red color for delete */
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 50%;
            line-height: 1;
            opacity: 0.6;
            transition: all 0.2s;
            background: rgba(229, 62, 62, 0.1);
            display: flex; /* Use flex for centering icon */
            align-items: center;
            justify-content: center;
            width: 24px; /* Fixed size */
            height: 24px;
        }
        .delete-btn:hover {
            opacity: 1;
            background: rgba(229, 62, 62, 0.2);
            transform: scale(1.15); /* Slightly larger hover scale */
            color: #fc8181; /* Lighter red on hover */
        }
        .task-input, .deadline-picker, .deadline-text {
            /* Input field styling */
            background: rgba(26, 32, 44, 0.9); /* Dark input background */
            border-radius: 0.75rem;
            padding: 0.9rem 1.25rem; /* Adjust padding */
            border: 1px solid rgba(79, 209, 197, 0.3);
            color: #e2e8f0; /* Light text color */
            transition: all 0.3s ease;
            width: 100%; /* Make inputs full width */
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
        }
        .task-input::placeholder, .deadline-picker::placeholder, .deadline-text::placeholder {
            color: #718096; /* Gray placeholder text */
        }
        .task-input:focus, .deadline-picker:focus, .deadline-text:focus {
            outline: none;
            border-color: #4fd1c5; /* Teal focus border */
            box-shadow: 0 0 0 3px rgba(79, 209, 197, 0.3); /* Teal focus ring */
            background: rgba(45, 55, 72, 0.95); /* Slightly lighter focus background */
        }
        .add-task-btn {
            /* Button styling */
            border-radius: 0.75rem;
            padding: 0.9rem 2rem;
            background: linear-gradient(135deg, #4fd1c5 0%, #38b2ac 100%); /* Teal gradient */
            color: #1a202c; /* Dark text on light button */
            font-weight: 600;
            transition: all 0.3s ease;
            border: none;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .add-task-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(79, 209, 197, 0.4); /* Teal glow on hover */
            background: linear-gradient(135deg, #81e6d9 0%, #4fd1c5 100%); /* Lighter teal gradient on hover */
        }
         .add-task-btn:active {
            transform: translateY(0px);
             box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .deadline-input-wrapper {
            /* Wrapper for deadline inputs */
            display: flex;
            align-items: center;
            gap: 0.5rem; /* Space between elements */
            flex-grow: 1; /* Allow wrapper to take available space */
        }
        .deadline-picker {
            flex-grow: 1; /* Allow picker to grow */
            margin-top: 0; /* Remove margin */
        }
        /* Hide text input by default */
        .deadline-text {
           display: none;
           flex-grow: 1;
           margin-top: 0;
        }
        .deadline-text.active {
            display: block; /* Show when active */
        }
        /* Hide picker when text is active */
        .deadline-picker.hidden {
            display: none;
        }
        .deadline-toggle {
            /* Toggle button styling */
            background: rgba(79, 209, 197, 0.15);
            border: 1px solid rgba(79, 209, 197, 0.3);
            color: #81e6d9; /* Light teal color */
            padding: 0.6rem; /* Adjust padding */
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2rem;
            width: 44px; /* Fixed width */
            height: 44px; /* Fixed height to match input */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Prevent shrinking */
            margin-top: 0; /* Remove margin */
        }
        .deadline-toggle:hover {
            background: rgba(79, 209, 197, 0.3);
            color: #fff;
        }
        .deadline-info {
            /* Deadline info styling */
            font-size: 0.8rem; /* Slightly smaller font */
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(79, 209, 197, 0.2);
            display: flex;
            align-items: center;
            gap: 0.4rem;
            color: #a0aec0; /* Lighter gray color */
            opacity: 0.9;
        }
        .deadline-info svg { /* Style the icon */
            width: 14px;
            height: 14px;
            stroke-width: 2;
        }
        .deadline-info.urgent {
            color: #fc8181; /* Light red for urgent */
        }
        .deadline-info.near {
            color: #f6ad55; /* Light orange for near */
        }
        #confetti-canvas {
            /* Confetti canvas styling */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through */
            z-index: 1000; /* Ensure it's above other elements */
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="container mx-auto">
        <header class="mb-10 text-center">
             <h1 class="text-5xl font-bold mb-3">Streamline</h1>
            <p class="text-lg">Organize your tasks with futuristic flair!</p>
        </header>

        <div class="add-task-section">
            <h2 class="text-2xl font-semibold">Add New Task</h2>
            <div class="flex flex-col gap-4">
                <input type="text" id="new-task-input" class="task-input flex-grow" placeholder="Enter task description...">
                <div class="flex flex-col sm:flex-row items-center gap-4">
                    <div class="deadline-input-wrapper w-full sm:w-auto">
                        <input type="datetime-local" id="task-deadline" class="deadline-picker" title="Select deadline date and time">
                        <input type="text" id="task-deadline-text" class="deadline-text" placeholder="e.g., tomorrow 3pm, next friday" title="Enter deadline description">
                        <button id="deadline-toggle" class="deadline-toggle" title="Toggle date picker/text input">
                            <i data-lucide="calendar-plus"></i>
                        </button>
                    </div>
                    <button id="add-task-btn" class="add-task-btn w-full sm:w-auto">
                         <i data-lucide="plus-circle"></i> Add Task
                    </button>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 md:gap-8">
            <div id="todo" class="kanban-column" data-column-id="todo">
                <h2 class="column-header text-teal-300">
                    <i data-lucide="list-todo" class="inline-block w-5 h-5 mr-2 align-middle"></i>To Do
                </h2>
                <div class="task-list space-y-4 pr-2">
                    </div>
            </div>

            <div id="inprogress" class="kanban-column" data-column-id="inprogress">
                 <h2 class="column-header text-cyan-300">
                     <i data-lucide="loader-circle" class="inline-block w-5 h-5 mr-2 align-middle"></i>In Progress
                 </h2>
                <div class="task-list space-y-4 pr-2">
                    </div>
            </div>

            <div id="done" class="kanban-column" data-column-id="done">
                 <h2 class="column-header text-green-300">
                     <i data-lucide="check-circle" class="inline-block w-5 h-5 mr-2 align-middle"></i>Done
                 </h2>
                <div class="task-list space-y-4 pr-2">
                    </div>
            </div>
        </div>
    </div>

    <canvas id="confetti-canvas"></canvas>

    <script>
        // DOM Elements
        const newTaskInput = document.getElementById('new-task-input');
        const addTaskBtn = document.getElementById('add-task-btn');
        const columns = document.querySelectorAll('.kanban-column');
        const confettiCanvas = document.getElementById('confetti-canvas');
        const ctx = confettiCanvas.getContext('2d');
        const deadlineToggle = document.getElementById('deadline-toggle');
        const deadlinePicker = document.getElementById('task-deadline');
        const deadlineText = document.getElementById('task-deadline-text');

        let tasks = []; // Array to store task objects { id, text, column, deadline }
        let draggedTask = null; // To keep track of the task element being dragged
        let confettiAnimationId; // To control confetti animation frame

        // --- Task Management ---

        /**
         * Creates a DOM element for a task.
         * @param {object} task - The task object { id, text, column, deadline }
         * @returns {HTMLElement} The task DOM element.
         */
        function createTaskElement(task) {
            const taskEl = document.createElement('div');
            taskEl.classList.add('task');
            taskEl.setAttribute('draggable', 'true');
            taskEl.setAttribute('data-task-id', task.id);

            // Task content wrapper
            const contentWrapper = document.createElement('div');

            // Task text
            const taskContent = document.createElement('span');
            taskContent.classList.add('task-content');
            taskContent.textContent = task.text;

            // Delete button with icon
            const deleteBtn = document.createElement('span');
            deleteBtn.classList.add('delete-btn');
            // Use Lucide trash icon
            deleteBtn.innerHTML = '<i data-lucide="trash-2" class="w-4 h-4"></i>';
            deleteBtn.title = 'Delete task';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering drag start
                deleteTask(task.id);
            });

            contentWrapper.appendChild(taskContent);
            // Append delete button directly to taskEl for absolute positioning
            taskEl.appendChild(contentWrapper);
            taskEl.appendChild(deleteBtn);

            // Add deadline info if exists
            if (task.deadline) {
                const deadlineInfo = document.createElement('div');
                deadlineInfo.classList.add('deadline-info');

                // Function to update deadline status and display
                function updateDeadlineStatus() {
                    const now = new Date();
                    const deadline = new Date(task.deadline);
                    const timeLeft = deadline - now;

                    // Clear existing classes and content
                    deadlineInfo.classList.remove('urgent', 'near');
                    deadlineInfo.innerHTML = ''; // Clear previous content

                    // Create icon span
                    const iconSpan = document.createElement('span');
                    iconSpan.innerHTML = '<i data-lucide="clock" class="w-3.5 h-3.5"></i>'; // Clock icon

                    // Create text span
                    const textSpan = document.createElement('span');

                    if (timeLeft < 0) {
                        textSpan.textContent = `Overdue by ${formatTimeLeft(-timeLeft)}`;
                        deadlineInfo.classList.add('urgent');
                        iconSpan.innerHTML = '<i data-lucide="alert-triangle" class="w-3.5 h-3.5"></i>'; // Warning icon
                    } else {
                        const formattedTime = formatTimeLeft(timeLeft);
                        textSpan.textContent = `${formattedTime} remaining`;
                        if (timeLeft < 24 * 60 * 60 * 1000) { // Less than 24 hours
                            deadlineInfo.classList.add('urgent');
                        } else if (timeLeft < 72 * 60 * 60 * 1000) { // Less than 3 days
                            deadlineInfo.classList.add('near');
                        }
                    }
                    deadlineInfo.appendChild(iconSpan);
                    deadlineInfo.appendChild(textSpan);
                    lucide.createIcons(); // Re-render Lucide icons if added dynamically
                }

                updateDeadlineStatus();
                // Update the countdown every minute
                const intervalId = setInterval(updateDeadlineStatus, 60000);
                // Store the interval ID on the element to clear it when the task is removed
                taskEl.dataset.intervalId = intervalId;

                taskEl.appendChild(deadlineInfo);
            }

            // Drag event listeners for the task element
            taskEl.addEventListener('dragstart', handleDragStart);
            taskEl.addEventListener('dragend', handleDragEnd);

            // Touch event listeners for mobile drag-and-drop
            taskEl.addEventListener('touchstart', handleTouchStart, { passive: false });
            taskEl.addEventListener('touchmove', handleTouchMove, { passive: false });
            taskEl.addEventListener('touchend', handleTouchEnd);

            // Render Lucide icons within the created task element
            lucide.createIcons({
                attrs: {
                    'stroke-width': 1.75, // Thinner lines for icons in tasks
                 },
                nodes: [deleteBtn] // Only render the delete icon initially
            });


            return taskEl;
        }

        /**
         * Formats milliseconds into a human-readable time string (e.g., "2d 3h", "5h 30m", "15m").
         * @param {number} ms - Time in milliseconds
         * @returns {string} Formatted time string
         */
        function formatTimeLeft(ms) {
            const totalMinutes = Math.floor(ms / (60 * 1000));
            const totalHours = Math.floor(totalMinutes / 60);
            const days = Math.floor(totalHours / 24);

            const minutes = totalMinutes % 60;
            const hours = totalHours % 24;

            let result = '';
            if (days > 0) {
                result += `${days}d `;
            }
            if (hours > 0) {
                result += `${hours}h `;
            }
            // Only show minutes if less than a day or if it's the only unit left
            if (days === 0 && minutes > 0) {
                 result += `${minutes}m`;
            }
             // If the total time is less than a minute show '<1m'
            if (result.trim() === '' && totalMinutes < 1) {
                return '<1m';
            }
             // If only days/hours are shown, remove trailing space
            return result.trim();
        }


        /**
         * Adds a new task to the "To Do" column based on user input.
         */
        function addNewTask() {
            const taskText = newTaskInput.value.trim();
            let deadline = null;
            let deadlineInputUsed = null; // Track which input was used

            // Determine deadline based on which input is visible
            if (!deadlinePicker.classList.contains('hidden') && deadlinePicker.value) {
                 deadline = deadlinePicker.value;
                 deadlineInputUsed = deadlinePicker;
            } else if (deadlineText.classList.contains('active') && deadlineText.value.trim()) {
                 const parsedDate = parseUserDate(deadlineText.value.trim());
                 if (parsedDate) {
                     deadline = parsedDate.toISOString();
                     deadlineInputUsed = deadlineText;
                 } else {
                     // Handle invalid date text input
                     deadlineText.classList.add('border-red-500');
                     deadlineText.focus();
                      // Add a temporary placeholder or message
                     const originalPlaceholder = deadlineText.placeholder;
                     deadlineText.value = ''; // Clear invalid input
                     deadlineText.placeholder = "Invalid date format!";
                     setTimeout(() => {
                         deadlineText.classList.remove('border-red-500');
                         deadlineText.placeholder = originalPlaceholder;
                     }, 2500);
                     return; // Stop task creation if date is invalid
                 }
            }


            // Validate task text
            if (taskText === '') {
                newTaskInput.classList.add('border-red-500'); // Use Tailwind for border
                newTaskInput.focus();
                const originalPlaceholder = newTaskInput.placeholder;
                newTaskInput.placeholder = "Task description cannot be empty!";
                setTimeout(() => {
                    newTaskInput.classList.remove('border-red-500');
                    newTaskInput.placeholder = originalPlaceholder;
                }, 2500);
                return;
            }

            // Create the new task object
            const newTask = {
                id: `task-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`, // More unique ID
                text: taskText,
                column: 'todo', // Default column
                deadline: deadline ? new Date(deadline).toISOString() : null // Ensure consistent format
            };

            tasks.push(newTask); // Add to the tasks array
            renderTasks(); // Update the UI
            saveTasksToLocalStorage(); // Persist changes

            // Clear inputs after adding
            newTaskInput.value = '';
            if (deadlineInputUsed === deadlinePicker) {
                deadlinePicker.value = '';
            } else if (deadlineInputUsed === deadlineText) {
                deadlineText.value = '';
            }
            newTaskInput.focus(); // Set focus back to task input
        }

        /**
         * Deletes a task by its ID from the tasks array and updates the UI and local storage.
         * @param {string} taskId - The ID of the task to delete.
         */
        function deleteTask(taskId) {
            const taskEl = document.querySelector(`[data-task-id="${taskId}"]`);
            // Clear the deadline update interval if it exists
            if (taskEl && taskEl.dataset.intervalId) {
                clearInterval(Number(taskEl.dataset.intervalId));
            }
            // Filter out the task to be deleted
            tasks = tasks.filter(task => task.id !== taskId);
            renderTasks(); // Re-render the task list
            saveTasksToLocalStorage(); // Update local storage
        }

        // --- Drag and Drop Functionality ---

        function handleDragStart(event) {
            draggedTask = this; // `this` refers to the task element being dragged
            // Use setTimeout to allow the browser to render the drag image before applying styles
            setTimeout(() => this.classList.add('dragging'), 0);
            event.dataTransfer.effectAllowed = 'move';
            // Set data payload (using task ID)
            event.dataTransfer.setData('text/plain', this.dataset.taskId);
        }

        function handleDragEnd() {
            // Remove dragging class regardless of drop success
            if (draggedTask) { // Check if draggedTask is still set
                 draggedTask.classList.remove('dragging');
            }
            draggedTask = null;
            // Clean up drag-over styling from all columns
            columns.forEach(col => col.classList.remove('drag-over'));
        }

        function handleDragOver(event) {
            event.preventDefault(); // Necessary to allow dropping
            event.dataTransfer.dropEffect = 'move';
            // Add visual feedback to the column being dragged over
            // Avoid adding class if already present to prevent flicker
            if (!this.classList.contains('drag-over')) {
                 this.classList.add('drag-over');
            }

             // --- Placeholder logic for drag over ---
             if (draggedTask) {
                const taskList = this.querySelector('.task-list');
                const afterElement = getDragAfterElement(taskList, event.clientY);
                const currentPlaceholder = taskList.querySelector('.task-placeholder');

                // Create placeholder if it doesn't exist in this column
                let placeholder = currentPlaceholder;
                if (!placeholder) {
                     // Remove placeholder from other columns first
                     document.querySelectorAll('.task-placeholder').forEach(p => p.remove());
                     placeholder = document.createElement('div');
                     placeholder.classList.add('task-placeholder');
                     placeholder.style.height = `${draggedTask.offsetHeight}px`; // Match height
                     placeholder.style.backgroundColor = 'rgba(79, 209, 197, 0.1)';
                     placeholder.style.border = '2px dashed rgba(79, 209, 197, 0.4)';
                     placeholder.style.borderRadius = '0.75rem';
                     placeholder.style.marginBottom = '1rem'; // Same margin as tasks
                     placeholder.style.transition = 'none'; // No transition for placeholder itself
                }


                // Insert the placeholder at the correct position
                if (afterElement == null) {
                    // Append to the end if no element is below the cursor
                    if (!taskList.lastElementChild || !taskList.lastElementChild.classList.contains('task-placeholder')) {
                        taskList.appendChild(placeholder);
                    }
                } else {
                     // Insert before the element below the cursor
                     if (afterElement !== placeholder) {
                        taskList.insertBefore(placeholder, afterElement);
                     }
                }
            }
        }

        // Helper function to determine where to insert the dragged item
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.task:not(.dragging):not(.task-placeholder)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                // Find the element whose midpoint is just below the cursor
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }


        function handleDragEnter(event) {
            event.preventDefault();
            // Add visual feedback - already handled by dragOver, but good for redundancy
            this.classList.add('drag-over');
        }

        function handleDragLeave(event) {
             // Remove visual feedback if not dragging over a child element
             // Check if the relatedTarget (where the mouse is going) is outside the current column
             if (!this.contains(event.relatedTarget)) {
                this.classList.remove('drag-over');
                // Remove placeholder if leaving the column entirely
                const placeholder = this.querySelector('.task-placeholder');
                if (placeholder) {
                    placeholder.remove();
                }
             }
        }

        function handleDrop(event) {
            event.preventDefault();
            this.classList.remove('drag-over'); // Remove drop zone styling
            const placeholder = this.querySelector('.task-placeholder');
             if (placeholder) {
                 placeholder.remove(); // Remove placeholder on drop
             }


            const taskId = event.dataTransfer.getData('text/plain');
            const targetColumnId = this.dataset.columnId; // Get the ID of the column where dropped

            const taskToMove = tasks.find(task => task.id === taskId);

            if (taskToMove && draggedTask) { // Ensure task exists and was being dragged
                const previousColumn = taskToMove.column;
                taskToMove.column = targetColumnId; // Update the task's column property

                // Trigger confetti if moved to "Done" from another column
                if (targetColumnId === 'done' && previousColumn !== 'done') {
                    // Get drop position for confetti origin
                    const dropRect = draggedTask.getBoundingClientRect();
                    triggerConfetti(dropRect.left + dropRect.width / 2, dropRect.top + dropRect.height / 2);
                }

                // Re-render tasks to reflect the change
                renderTasks();
                saveTasksToLocalStorage(); // Persist the change
            }
             draggedTask = null; // Reset draggedTask after drop
        }

        // --- Touch Drag and Drop Emulation ---
        let touchDragElement = null; // The element visually moved during touch drag
        let touchStartX, touchStartY; // Initial touch coordinates
        let currentDroppable = null; // The column currently being touched over
        let placeholderElement = null; // Placeholder for touch drag visual feedback
        let originalTaskElement = null; // Reference to the actual task element being dragged

         function handleTouchStart(event) {
            // Only allow dragging with one finger
            if (event.touches.length > 1) return;

            originalTaskElement = this; // The actual task element touched
            originalTaskElement.style.opacity = '0.5'; // Make original slightly transparent

            // Clone the element for visual dragging feedback
            touchDragElement = this.cloneNode(true);
            touchDragElement.style.position = 'fixed'; // Position fixed for dragging
            touchDragElement.style.zIndex = '1000';
            touchDragElement.style.pointerEvents = 'none'; // Don't interfere with elementFromPoint
            touchDragElement.style.width = `${this.offsetWidth}px`; // Maintain width
            touchDragElement.style.height = `${this.offsetHeight}px`; // Maintain height
            touchDragElement.style.transition = 'none'; // No transitions while dragging clone
            touchDragElement.classList.add('dragging'); // Apply dragging style to clone
            document.body.appendChild(touchDragElement); // Add clone to body

            // Create placeholder
            placeholderElement = document.createElement('div');
            placeholderElement.classList.add('task-placeholder'); // Use the same placeholder class
            placeholderElement.style.height = `${this.offsetHeight}px`;
            placeholderElement.style.backgroundColor = 'rgba(79, 209, 197, 0.1)';
            placeholderElement.style.border = '2px dashed rgba(79, 209, 197, 0.4)';
            placeholderElement.style.borderRadius = '0.75rem';
            placeholderElement.style.marginBottom = '1rem';
            placeholderElement.style.transition = 'none';

            // Calculate offset within the element
            const rect = this.getBoundingClientRect();
            touchStartX = event.touches[0].clientX - rect.left;
            touchStartY = event.touches[0].clientY - rect.top;

            // Position the clone initially
            touchDragElement.style.left = (event.touches[0].clientX - touchStartX) + 'px';
            touchDragElement.style.top = (event.touches[0].clientY - touchStartY) + 'px';

             // Insert placeholder where the original element was
             this.parentNode.insertBefore(placeholderElement, this);

            event.preventDefault(); // Prevent scrolling
        }

        function handleTouchMove(event) {
            if (!touchDragElement || event.touches.length > 1) return;
            event.preventDefault(); // Prevent scrolling

            const touchX = event.touches[0].clientX;
            const touchY = event.touches[0].clientY;

            // Move the cloned element
            touchDragElement.style.left = (touchX - touchStartX) + 'px';
            touchDragElement.style.top = (touchY - touchStartY) + 'px';

            // --- Droppable detection ---
            // Temporarily hide the clone to find element underneath
            touchDragElement.style.display = 'none';
            const elementBelow = document.elementFromPoint(touchX, touchY);
            touchDragElement.style.display = ''; // Show clone again

            let targetColumnElement = elementBelow;
            // Traverse up to find the kanban column
            while (targetColumnElement && !targetColumnElement.classList.contains('kanban-column')) {
                targetColumnElement = targetColumnElement.parentElement;
            }

            // If over a new column or no column
            if (targetColumnElement !== currentDroppable) {
                // Remove highlight and placeholder from previous column
                if (currentDroppable) {
                    currentDroppable.classList.remove('drag-over');
                     if (placeholderElement.parentNode === currentDroppable.querySelector('.task-list')) {
                         placeholderElement.remove();
                     }
                }
                currentDroppable = targetColumnElement; // Update current droppable
                // Add highlight to the new column
                if (currentDroppable) {
                    currentDroppable.classList.add('drag-over');
                }
            }

            // --- Placeholder positioning within the current column ---
            if (currentDroppable) {
                const taskList = currentDroppable.querySelector('.task-list');
                 // Use the same helper function as desktop drag/drop
                const afterElement = getDragAfterElement(taskList, touchY);

                // Insert placeholder at the correct position
                if (afterElement == null) {
                    taskList.appendChild(placeholderElement);
                } else {
                    taskList.insertBefore(placeholderElement, afterElement);
                }
            } else {
                 // If not over any column, remove the placeholder
                 if (placeholderElement.parentNode) {
                    placeholderElement.remove();
                 }
            }
        }

        function handleTouchEnd(event) {
            if (!touchDragElement) return;

            // Restore original element visibility
             if(originalTaskElement) {
                originalTaskElement.style.opacity = '';
             }

            // Remove the cloned element
            document.body.removeChild(touchDragElement);
            touchDragElement = null;

            // Remove placeholder
            if (placeholderElement && placeholderElement.parentNode) {
                placeholderElement.remove();
            }
            placeholderElement = null;

            // If dropped on a valid column
            if (currentDroppable && originalTaskElement) {
                currentDroppable.classList.remove('drag-over');
                const targetColumnId = currentDroppable.dataset.columnId;
                const taskId = originalTaskElement.dataset.taskId;

                const taskToMove = tasks.find(task => task.id === taskId);
                if (taskToMove) {
                    const previousColumn = taskToMove.column;
                    taskToMove.column = targetColumnId; // Update task data

                     // Trigger confetti if moved to "Done"
                     if (targetColumnId === 'done' && previousColumn !== 'done') {
                         const dropRect = originalTaskElement.getBoundingClientRect(); // Use original element's position
                         triggerConfetti(dropRect.left + dropRect.width / 2, dropRect.top + dropRect.height / 2);
                     }

                    renderTasks(); // Re-render UI
                    saveTasksToLocalStorage(); // Save changes
                }
            } else {
                // If not dropped on a valid column, re-render to snap back
                renderTasks();
            }

            // Reset states
            currentDroppable = null;
            originalTaskElement = null;
        }


        // --- Rendering and Local Storage ---

        /**
         * Renders all tasks from the `tasks` array into their respective columns in the DOM.
         */
        function renderTasks() {
            // Clear existing tasks from columns, but keep headers
            columns.forEach(column => {
                const taskList = column.querySelector('.task-list');
                 // Clear interval timers for tasks about to be removed
                 taskList.querySelectorAll('.task[data-interval-id]').forEach(taskEl => {
                     clearInterval(Number(taskEl.dataset.intervalId));
                 });
                taskList.innerHTML = ''; // Clear the list content
            });

            // Sort tasks (optional, e.g., by deadline or creation time)
            // tasks.sort((a, b) => (a.deadline && b.deadline) ? new Date(a.deadline) - new Date(b.deadline) : 0);

            // Add tasks to their correct columns
            tasks.forEach(task => {
                const taskEl = createTaskElement(task); // Create the DOM element
                const columnEl = document.getElementById(task.column);
                if (columnEl) {
                    columnEl.querySelector('.task-list').appendChild(taskEl); // Append to the column's task list
                } else {
                    console.warn(`Column with ID ${task.column} not found for task ${task.id}. Defaulting to 'todo'.`);
                    // Optionally move task back to 'todo' if its column doesn't exist
                    task.column = 'todo';
                    document.getElementById('todo').querySelector('.task-list').appendChild(taskEl);
                    saveTasksToLocalStorage(); // Save the correction
                }
            });

             // Re-initialize Lucide icons for any dynamically added icons (like in deadlines)
             lucide.createIcons();
        }

        /**
         * Saves the current `tasks` array to local storage as a JSON string.
         */
        function saveTasksToLocalStorage() {
            try {
                localStorage.setItem('kanbanTasksFuturistic', JSON.stringify(tasks));
            } catch (e) {
                console.error("Failed to save tasks to local storage:", e);
                // Optionally notify the user
            }
        }

        /**
         * Loads tasks from local storage and populates the `tasks` array.
         */
        function loadTasksFromLocalStorage() {
            const storedTasks = localStorage.getItem('kanbanTasksFuturistic');
            if (storedTasks) {
                try {
                    tasks = JSON.parse(storedTasks);
                     // Basic validation (ensure it's an array)
                     if (!Array.isArray(tasks)) {
                         console.warn("Invalid data found in local storage. Resetting tasks.");
                         tasks = [];
                     }
                     // Further validation could check task structure
                } catch (e) {
                    console.error("Failed to parse tasks from local storage:", e);
                    tasks = []; // Reset to empty array on parsing error
                }
            } else {
                tasks = []; // Initialize with empty array if nothing is stored
            }
        }


        // --- Confetti Animation ---
        let confettiParticles = [];
        // Futuristic color palette for confetti
        const confettiColors = ['#4fd1c5', '#81e6d9', '#38b2ac', '#4dc0b5', '#319795', '#ffffff', '#e2e8f0'];

        function ConfettiParticle(startX, startY) {
            // Start confetti from where the task was dropped or center if not specified
            this.x = startX || confettiCanvas.width / 2;
            this.y = startY || confettiCanvas.height / 2;
            this.size = Math.random() * 6 + 4; // Slightly larger confetti
            this.speedX = Math.random() * 8 - 4; // Wider horizontal spread
            this.speedY = Math.random() * -12 - 6; // Stronger initial upward burst
            this.color = confettiColors[Math.floor(Math.random() * confettiColors.length)];
            this.opacity = 1;
            this.rotation = Math.random() * 360;
            this.spin = Math.random() * 16 - 8; // Faster spin
            this.gravity = 0.25; // Slightly stronger gravity
            this.drag = 0.98; // Air resistance
        }

        ConfettiParticle.prototype.update = function() {
            this.speedX *= this.drag; // Apply air resistance
            this.x += this.speedX;
            this.speedY += this.gravity; // Apply gravity
            this.y += this.speedY;
            this.opacity -= 0.008; // Slower fade out
            this.rotation += this.spin;
        };

        ConfettiParticle.prototype.draw = function() {
            ctx.save();
            ctx.globalAlpha = this.opacity < 0 ? 0 : this.opacity; // Ensure alpha doesn't go below 0
            ctx.fillStyle = this.color;
            ctx.translate(this.x + this.size / 2, this.y + this.size / 2);
            ctx.rotate(this.rotation * Math.PI / 180);
            // Draw slightly different shapes (mix rectangles and squares)
            if (Math.random() > 0.5) {
                 ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size); // Square
            } else {
                 ctx.fillRect(-this.size / 2, -this.size / 2, this.size * 0.8, this.size * 1.5); // Rectangle
            }
            ctx.restore();
        };

        function triggerConfetti(x, y) {
            // Ensure canvas dimensions are up-to-date
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
            confettiParticles = []; // Clear previous particles
            const numberOfParticles = 180; // More particles
            for (let i = 0; i < numberOfParticles; i++) {
                confettiParticles.push(new ConfettiParticle(x, y)); // Pass starting coordinates
            }
             // Start animation if not already running
             if (!confettiAnimationId) {
                animateConfetti();
             }
        }

        function animateConfetti() {
            ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            let stillAnimating = false;
            confettiParticles = confettiParticles.filter(particle => {
                if (particle.opacity > 0 && particle.y < confettiCanvas.height + particle.size) { // Check if visible or just below screen
                    particle.update();
                    particle.draw();
                    stillAnimating = true; // Continue animation if any particle is still active
                    return true; // Keep particle
                }
                return false; // Remove particle
            });

            if (stillAnimating) {
                confettiAnimationId = requestAnimationFrame(animateConfetti);
            } else {
                 // Clear canvas completely when animation stops
                 ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
                cancelAnimationFrame(confettiAnimationId);
                confettiAnimationId = null; // Reset animation ID
            }
        }

        // --- Date Parsing ---

        /**
        * Parses user-friendly date/time strings into Date objects.
        * Handles formats like "today", "tomorrow 5pm", "next friday", "2 days from now", "2025-05-20 14:30".
        * @param {string} input - The user's date/time string.
        * @returns {Date|null} A Date object or null if parsing fails.
        */
        function parseUserDate(input) {
            input = input.toLowerCase().trim();
            const now = new Date();
            let date = new Date(now); // Start with a copy of now

            // --- Simple Relative Terms ---
            if (input === 'today') {
                date.setHours(17, 0, 0, 0); // Default to 5 PM today
                return date;
            }
            if (input === 'tomorrow') {
                date.setDate(now.getDate() + 1);
                date.setHours(9, 0, 0, 0); // Default to 9 AM tomorrow
                return date;
            }

            // --- Days of the Week ---
            const daysOfWeek = { 'sunday': 0, 'monday': 1, 'tuesday': 2, 'wednesday': 3, 'thursday': 4, 'friday': 5, 'saturday': 6 };
            for (const day in daysOfWeek) {
                if (input.includes(day)) {
                    const targetDay = daysOfWeek[day];
                    let daysToAdd = (targetDay - now.getDay() + 7) % 7;
                    if (daysToAdd === 0 && input.startsWith('next')) { // Handle "next monday" if today is Monday
                        daysToAdd = 7;
                    } else if (daysToAdd === 0 && !input.startsWith('next')) { // Handle "monday" if today is Monday (means *this* Monday)
                        // Keep daysToAdd = 0, unless time is specified and past
                    } else if (daysToAdd === 0) { // Default case if today is the day, assume next week
                         daysToAdd = 7;
                    }

                    date.setDate(now.getDate() + daysToAdd);
                    // Check for time specification with day
                    const timePart = input.split(day)[1]?.trim();
                    if (timePart) {
                         const parsedTime = parseTime(timePart);
                         if (parsedTime) {
                             date.setHours(parsedTime.hours, parsedTime.minutes, 0, 0);
                         } else {
                             date.setHours(9, 0, 0, 0); // Default time if only day is mentioned
                         }
                    } else {
                         date.setHours(9, 0, 0, 0); // Default time
                    }
                    return date;
                }
            }

             // --- Relative Time ("in X units") ---
             const relativeMatch = input.match(/^(?:in\s+)?(\d+)\s+(min|hour|day|week)s?(?:\s+from now|\s+later)?$/);
             if (relativeMatch) {
                 const [, amount, unit] = relativeMatch;
                 const numAmount = parseInt(amount);
                 switch (unit) {
                     case 'min': date.setMinutes(now.getMinutes() + numAmount); break;
                     case 'hour': date.setHours(now.getHours() + numAmount); break;
                     case 'day': date.setDate(now.getDate() + numAmount); break;
                     case 'week': date.setDate(now.getDate() + numAmount * 7); break;
                 }
                 return date;
             }

             // --- Specific Date Formats (YYYY-MM-DD, MM/DD/YYYY, etc.) with optional time ---
             // Attempt direct parsing first - this handles ISO-like formats well
             const directParse = new Date(input);
             if (!isNaN(directParse.getTime()) && input.match(/\d{4}/)) { // Check if it's a valid date and likely contains a year
                 // Basic check to avoid parsing just "10" as a date
                 if (input.length > 4 || input.includes('/') || input.includes('-') || input.includes(':')) {
                    return directParse;
                 }
             }

             // --- Try parsing combined date and time like "MM/DD/YYYY HH:MM" or "tomorrow 3pm" ---
             let datePartStr = input;
             let timePartStr = null;

             // Look for common time indicators (am/pm, :)
             const timeIndicatorMatch = input.match(/(\d{1,2}(?::\d{2})?\s*(?:am|pm)?)$/);
             if (timeIndicatorMatch) {
                 timePartStr = timeIndicatorMatch[1];
                 datePartStr = input.substring(0, input.lastIndexOf(timePartStr)).trim();
                 if (!datePartStr) datePartStr = 'today'; // Assume today if only time is given
             }

             const parsedDatePart = parseUserDate(datePartStr); // Recursive call for the date part
             if (parsedDatePart) {
                 const parsedTime = timePartStr ? parseTime(timePartStr) : { hours: 17, minutes: 0 }; // Default time if needed
                 if (parsedTime) {
                     parsedDatePart.setHours(parsedTime.hours, parsedTime.minutes, 0, 0);
                     return parsedDatePart;
                 }
             }


            // If nothing matches, return null
            return null;
        }

        /**
        * Helper function to parse time strings (e.g., "5pm", "14:30", "9 AM").
        * @param {string} timeInput - The time string.
        * @returns {{hours: number, minutes: number}|null} Parsed time or null.
        */
        function parseTime(timeInput) {
             timeInput = timeInput.toLowerCase().trim();
             const timeMatch = timeInput.match(/^(\d{1,2})(?::(\d{2}))?\s*(am|pm)?$/);
             if (timeMatch) {
                 let [, hours, minutes = '0', meridiem] = timeMatch;
                 hours = parseInt(hours);
                 minutes = parseInt(minutes);

                 if (hours > 23 || minutes > 59) return null; // Invalid time

                 if (meridiem === 'pm' && hours < 12) {
                     hours += 12;
                 } else if (meridiem === 'am' && hours === 12) { // Handle 12 AM (midnight)
                     hours = 0;
                 }
                 // Assume 24-hour format if no meridiem and hour > 12
                 return { hours, minutes };
             }
             return null;
        }


        // --- Event Listeners Setup ---
        addTaskBtn.addEventListener('click', addNewTask);

        // Allow adding task by pressing Enter in the input fields
        newTaskInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent form submission if inside a form
                addNewTask();
            }
        });
        deadlineText.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                 e.preventDefault();
                addNewTask();
            }
        });


        // Add drag event listeners to columns
        columns.forEach(column => {
            column.addEventListener('dragover', handleDragOver);
            column.addEventListener('dragenter', handleDragEnter);
            column.addEventListener('dragleave', handleDragLeave);
            column.addEventListener('drop', handleDrop);
        });

        // Add toggle functionality for deadline input
        deadlineToggle.addEventListener('click', () => {
            const isPickerVisible = !deadlinePicker.classList.contains('hidden');

            // Toggle visibility classes
            deadlinePicker.classList.toggle('hidden');
            deadlineText.classList.toggle('active'); // Uses .active to show/hide via CSS

            // Update toggle button icon and title
            const toggleIcon = deadlineToggle.querySelector('i');
            if (isPickerVisible) {
                // Switched TO text input
                toggleIcon.setAttribute('data-lucide', 'calendar-check'); // Icon indicating date picker is available
                deadlineToggle.title = 'Switch to date picker input';
                // Try to convert picker value to text
                if (deadlinePicker.value) {
                    try {
                        const date = new Date(deadlinePicker.value);
                        // Format nicely for the text input
                        deadlineText.value = date.toLocaleString([], { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true });
                    } catch (e) { deadlineText.value = ''; } // Clear if error
                } else {
                    deadlineText.value = '';
                }
                deadlineText.focus(); // Focus the text input
            } else {
                // Switched TO picker input
                toggleIcon.setAttribute('data-lucide', 'text-cursor-input'); // Icon indicating text input is available
                deadlineToggle.title = 'Switch to text input';
                // Try to parse text input and set picker value
                if (deadlineText.value) {
                    const parsedDate = parseUserDate(deadlineText.value);
                    if (parsedDate) {
                        try {
                             // Format for datetime-local (YYYY-MM-DDTHH:mm)
                             const year = parsedDate.getFullYear();
                             const month = (parsedDate.getMonth() + 1).toString().padStart(2, '0');
                             const day = parsedDate.getDate().toString().padStart(2, '0');
                             const hours = parsedDate.getHours().toString().padStart(2, '0');
                             const minutes = parsedDate.getMinutes().toString().padStart(2, '0');
                             deadlinePicker.value = `${year}-${month}-${day}T${hours}:${minutes}`;
                        } catch(e) { deadlinePicker.value = '';} // Clear if error
                    } else {
                        deadlinePicker.value = ''; // Clear picker if text wasn't valid
                    }
                } else {
                     deadlinePicker.value = '';
                }
                deadlinePicker.focus(); // Focus the picker
            }
             lucide.createIcons({ nodes: [toggleIcon] }); // Update the icon
        });

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadTasksFromLocalStorage(); // Load saved tasks
            renderTasks(); // Display tasks on the board

             // Initialize Lucide icons on load
             lucide.createIcons();

            // Adjust confetti canvas size on window resize
            window.addEventListener('resize', () => {
                 // Only resize if an animation is potentially active or recently finished
                 if (confettiParticles.length > 0 || confettiAnimationId) {
                    confettiCanvas.width = window.innerWidth;
                    confettiCanvas.height = window.innerHeight;
                 }
            });

            // Set initial state for deadline input (picker visible)
            deadlinePicker.classList.remove('hidden');
            deadlineText.classList.remove('active');
            deadlineText.style.display = 'none'; // Ensure text is hidden initially
            const initialToggleIcon = deadlineToggle.querySelector('i');
            initialToggleIcon.setAttribute('data-lucide', 'text-cursor-input'); // Start with text input icon
            deadlineToggle.title = 'Switch to text input';
            lucide.createIcons({ nodes: [initialToggleIcon] });

        });
    </script>
</body>
</html>
